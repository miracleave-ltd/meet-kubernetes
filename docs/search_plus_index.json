{"./":{"url":"./","title":"はじめに","keywords":"","body":"はじめに 前提 Docker Desktop Git ※Windows/MacOSで確認しました。 Kubernetes Docker Desktopには、Kubernetesサーバーとクライアントが内包されています。 Dockerインスタンス内でローカルに実行され、単一ノードクラスターとなっています。 タスクバーにあるを右クリックして、 Settings を選択してください。 メニューにある Kubernetes を選択してください。 Enable Kubernetes をチェックし、 Apply&Restart をクリックしてください。 しばらくすると③の箇所にKubernetes Runningと表示します。 Kompose Windowsの場合 Windowsでは、Chocolateyでインストールできます。 ※Chocolateryをインストールしていない方はこちら choco install kubernetes-kompose MacOSの場合 MacOSでは、Homebrewでインストールできます。 ※Homebrewをインストールしていない方はこちら brew install kompose "},"Section1.html":{"url":"Section1.html","title":"セクション１","keywords":"","body":"Section1 目次 No.1 Dockerとは No.2 Kubernetesとは No.3 Kubernetesが生まれた歴史 No.4 Kubernetesのそれぞれのサービスの概要 No.5 Komposeとは Dockerとは 概要 Dockerは、アプリケーションを開発、出荷、実行するためのオープンプラットフォームです。Dockerを使用すると、アプリケーションをインフラストラクチャから分離できるため、ソフトウェアを迅速に提供できます。Dockerを使用すると、アプリケーションを管理するのと同じ方法でインフラストラクチャを管理できます。コードを迅速に出荷、テスト、デプロイするためのDockerの方法論を利用することで、コードの記述から本番環境での実行までの遅延を大幅に減らすことができます。 画像（VirtualBoxとdockerを比較している写真） Dockerコンテナのメリット ・資源の効率化 Dockerはホストカーネルを共有し、従来のハイパーバイザ型のHyper-Vやホスト型のVirtualBox等のようにOSを丸ごとインストールする必要がなく資源を効率的に扱える。 ・アプリ実行環境構築の容易さ Dockerはアプリケーションとライブラリを同一のコンテナ内に固めることができ、一度固めたコンテナは軽量で持ち運びが容易。DockerがインストールされているOSであれば移動が容易に行える。 ・設定間違いなどの不可逆的操作の廃棄の容易さ 複雑なシステムであれば一度設定を間違えると、影響範囲の調査などに時間がかる可能性があります。しかしDockerであれば設定を間違えたと思えばすぐさま削除することができる。変更も「Docker file」を修正することで再構築でき、イメージを段階的に残しておくことで設定間違いの前の状態にすぐにもどることができる。 Kubernetes(K8s)とは Kubernetes（クバネティス/クバネテス/クーべネティス、K8s）は、コンテナ化したアプリケーションのデプロイ、スケーリング、および管理を行うための、オープンソースのコンテナオーケストレーションシステムである。 Kubernetesでできること サービス検出と負荷分散 Kubernetesは、DNS名または独自のIPアドレスを使用してコンテナを公開できます。コンテナへのトラフィックが多い場合、Kubernetesはネットワークトラフィックを負荷分散して分散できるため、デプロイが安定します。 ストレージオーケストレーション Kubernetesを使用すると、ローカルストレージ、パブリッククラウドプロバイダー(AWS,Azuru,GCP)など、選択したストレージシステムを自動的にマウントできます。 自動ロールアウトとロールバック Kubernetesを使用して、デプロイされたコンテナの目的の状態を記述でき、制御されたレートで実際の状態を目的の状態に変更できます。たとえば、Kubernetesを自動化して、デプロイ用の新しいコンテナを作成し、既存のコンテナを削除して、すべてのリソースを新しいコンテナに採用できます。 自動ビンパッキング Kubernetesに、コンテナ化されたタスクの実行に使用できるノードのクラスターを提供します。各コンテナに必要なCPUとメモリ（RAM）の量をKubernetesに伝えます。Kubernetesは、コンテナをノードに適合させて、リソースを最大限に活用できます。 自己修復 Kubernetesは、失敗したコンテナを再起動し、コンテナを置き換え、ユーザー定義のヘルスチェックに応答しないコンテナを強制終了し、サービスを提供する準備ができるまでクライアントにアドバタイズしません。 シークレットと構成の管理 Kubernetesを使用すると、パスワード、OAuthトークン、SSHキーなどの機密情報を保存および管理できます。コンテナイメージを再構築したり、スタック構成でシークレットを公開したりすることなく、シークレットとアプリケーション構成をデプロイおよび更新できます。 Kubernetesが生まれた背景 VMが登場する以前 アプリケーションを展開するために、オペレーティングシステムのパッケージマネージャを使用してアプリケーションをホストにインストールしていました。しかし、この方法だと、アプリケーションの実行可能ファイル、ライブラリ、ライフサイクル、OSなどが互いに依存してしまうという難点がありました。 VMが登場 そこで登場したのが「VM」でした。VMが登場したことによってハードウェアレベルでの仮想化がすすみ、一台のサーバ上に複数のオペレーティングシステム (OS) を走らせることができるようになりました。しかし、VMも移植性がなく、重いという欠点がありました。 Dockerの登場 VMの重い、移植性がない、資源(resource)の浪費が激しいなどの欠点を克服したのがDockerでした。コンテナはVMに比べて構築が容易（Dockerfileを用いて）で、コンテナ同士は互いに独立的であり、OSのカーネルを共有することで資源(resource)の浪費を軽減し、クラウド間などで移植するといったことが可能になりました。 Kubernetesの登場 しかし今度はDockerの管理の問題が浮上しました。 数台レベルでコンテナを立ち上げるのはそこまで大変ではなかったものの、規模が大きくなってくるとコンテナの構成、コンテナ管理、死活管理などの運用がとても大変になってしまいました。そんな悩みを解決するべく現れたのがkubernetesです。 kubernetesはアプリケーションの死活管理、オートスケール、ロードバランシング、リソース監視など、さまざまなニーズを満たす機能を備えています。また、Kubernetesは、主にマイクロサービスなどの複数のコンテナで構成されるアプリケーションを対象としていて非コンテナ化されたアプリケーションのKubernetesへの移行を容易にし、多数のクラウドプロバイダーと物理ホスト上で動作するように設計されています Kubernetesのそれぞれのサービスの概要 画像元https://kubernetes.io/ja/docs/concepts/overview/components/ コンポーネント コンポーネントとはk8sを構成しているものです。 大きく分けてコントロールプレーンとノードがあります。 名前 役割 Control Planes k8sの心臓部分。指揮者的な役割別名：Admin、Master Nodes 実際にコンテナが動作する環境。演奏する側別名：ワーカー クラスタ(Kubernetes Cluster) クラスタとは、アプリケーションを実行するためにKubernetesが使用する物理マシンや仮想マシン、その他のインフラリソースのセットのことを指します。 つまり、Control PlanesとNodesのまとまった単位をクラスタと呼びます。 コンポーネント（Control Planes） 名前 役割 kube-apiserver k8s　APIを公開している etcd K8sクラスタ情報の保存場所。key/valueストア kube-scheduler Pod(コンテナ)をワーカーノードに割り当てる kube-controller-manager k8sの操作全般を担当する(Podを起動したり、障害を検知したり) cloud-controller-manager クラウド（AWS/GCP/Azuruなど）の機能と連携する(ロードバランサー) コンポーネント（Nodes） 名前 役割 kubelt 各ノードで実行されるエージェントマスターノードとやりとりして指示に従う kube-proxy NodeのNWルール（iptablesなど）を追加、削除、変更している コンテナランタイム コンテナを実行するためのソフトウェア ノード(Node) ノードは、Kubernetesを実行している物理マシンまたは仮想マシンで、ポッドを動かします。(スケジューリング) ポッド(Pod) ポッドは複数のコンテナの集合です。Kubernetesの最小単位です。 ラベル(Label) ラベルは、ポッドなどのリソースにアタッチされるキー/値のペアです。ラベルを使用して、リソースのサブセットを整理し、選択することができます。 レプリカセット(Replica Set) 元々はレプリケーションコントローラという名前でしたが、レプリカセットという名前になりました。 レプリカセットは、指定した数のポッドレプリカがいつでも実行されていることを確認します。両方とも、複製されたシステムの簡単なスケーリングを可能にし、ポッドが再起動したとき、または失敗したときにポッドの再作成を処理します。 サービス(Service) サービスは、単一の安定したIPアドレスや対応するDNS名など、一連のポッドとそれらにアクセスする手段を定義します。ロードバランサのようなものです。この「サービス」という命名に、マイクロサービスへの意識が感じられます。(個人的な感想です) シークレット(Secret) Secretは、認証トークンなどの機密データを保管し、要求に応じてコンテナに提供することができます。イケてますね。 ネームスペース(Namespace) 名前空間は、リソース名の接頭辞に似ています。 (マイクロサービスなどにおける)チーム間での名前の衝突を防ぐなど、さまざまなプロジェクト、チーム、または顧客がクラスタを共有する際に役立ちます。 kubectl API経由でKubenetesを操作するためのクライアントツール アノテーション(Annotations) 識別できない補助データ（特に、ツールやシステム拡張によって操作されるデータ）を格納するために、（ラベルと比較して）大きくて人間が読めるものではないデータを保持できるキーと値のペア。アノテーション値による効率的なフィルタリングはサポートされていません。 Deployments DeploymentsはPodの管理をします。 Deploymentオブジェクトの目的の状態を記述するだけで、目的の状態に変更してくれます。神ってる。 Komposeとは Docker Composeの設定ファイルをKubernetes向けに変換するツールです。 また、変換によって生成されたリソース群を、docker-composeライクなインタフェースで制御することもできます。 "},"Section2.html":{"url":"Section2.html","title":"セクション２","keywords":"","body":"Section2 Komposeを利用して、Kubernetes用yamlを作成しよう React+Go(Gin)+PostgresSQLのTodoアプリを使用していきます。 今回利用するアプリをGitHubよりプログラムをダウンロードします。 ローカル環境にDockerイメージを作成します。 ※ダウンロードしたファイルを解凍したフォルダで実行してください。 フロントアプリのビルドを行います。 次のコマンドを実行してください。 docker-compose run client npm run build バックエンドのビルドを行います。 次のコマンドを実行してください。 docker-compose run server go build アプリイメージのビルドを行います。 次のコマンドを実行してください。 docker-compose -f docker-compose.prod.yml build Komposeでは、docker-compose.ymlファイルにKompose用Labelsを記載することで、Kompose用の設定を行うことができます。 参考URL：https://kompose.io/user-guide/ 今回は以下の３点を修正します。 ローカルでKubernetesを実行するため、 kompose.service.type を設定します。 ローカルコンテナイメージを利用するため、 kompose.image-pull-policy を設定します。 Komposeで depends_on が対応していないため、 port を追加で設定します。 対象ファイル：(go-react-todo-master)/docker-compose.prod.yml※port,labelsを追加しています。 version: '3' services: postgres: image: postgres environment: - POSTGRES_PASSWORD=postgres ports: - \"5432:5432\" server: build: ./server command: ./app ports: - \"3001\" depends_on: - \"postgres\" environment: - POSTGRES_PASSWORD=postgres labels: kompose.image-pull-policy: Never nginx: build: ./nginx ports: - \"8000:80\" labels: kompose.service.type: nodeport kompose.image-pull-policy: Never Komposeコマンドでdocker-compose.ymlを変換します。 docker-compose.yml を変換する場合は、 -f 以降は不要です。 今回は開発時の者は不要ですので、production環境用のymlファイルをもとに変換します。 ※ダウンロードしたファイルを解凍したフォルダで実行してください。 kompose convert -f docker-compose.prod.yml (WindowsPowerShell) 変換後の確認を行います。 次のファイルが生成されていることを確認してください。 nginx-service.yaml postgres-service.yaml server-service.yaml nginx-deployment.yaml postgres-deployment.yaml server-deployment.yaml Kubernetes用のyamlファイルは生成できたのですが、Komposeの変換だけでは対応しきれない部分の修正を行います。 ローカルイメージを取得するため、ローカルイメージ名を記載します。 対象ファイル：(go-react-todo)/server-deployment.yaml - [36] image: server + [36] image: go-react-todo-master_server 対象ファイル：(go-react-todo)/nginx-deployment.yaml - [33] - image: nginx + [33] - image: go-react-todo-master_nginx Kubernetesに変換したファイルをKubernetesに反映します。 kubectl apply -f nginx-service.yaml -f postgres-service.yaml -f server-service.yaml -f nginx-deployment.yaml -f postgres-deployment.yaml -f server-deployment.yaml (WindowsPowerShell) Kubernetesの状態確認を行います。 kubectl get pods,deploy,svc ※deploy -> deployments, svc -> services (WindowsPowerShell) Kubernetesに反映したプロジェクトを確認します。 Kubernetesの状態確認を行った際にNginxの公開されているポートを確認します。 NodePortは動的にポート番号を割り振るため、個々の端末によって異なります。 上記で確認したポート番号のLocalhostにアクセスしてください。 http://localhost:XXXXX Todoアプリが表示しましたらデプロイ完了です。 "},"Section3.html":{"url":"Section3.html","title":"セクション３","keywords":"","body":"Section3 修正したプログラムを反映しよう 実際にファイルを修正して、実際に修正された内容をどのようにデプロイするか確認してみましょう。 次のファイルを修正してください。 青背景から赤背景に変更します。 対象ファイル：(go-react-todo-master)/client\\src\\stylesheets\\main.less - [2] background-color:lightcyan; + [2] background-color:lightcoral; - [6] background-color:lightcyan; + [6] background-color:lightcoral; 修正したファイルをビルドします。 docker-compose run --rm client npm run build ビルドしたファイルをイメージにするため、イメージビルドを行います。 docker-compose -f docker-compose.prod.yml build Kubernetesにデプロイします。 kubectl rollout restart deploy nginx 赤い背景色になったらデプロイ完了です。 "},"Section4.html":{"url":"Section4.html","title":"セクション４","keywords":"","body":""},"Section5.html":{"url":"Section5.html","title":"セクション５","keywords":"","body":"Section5 今回のハンズオンで汚してしまった環境を片づけます。 kubernetesからdeploymentsの情報を取得して、現在存在するdeploymentsの情報をKubernetesから削除します。 kubectl get deploy # NAME READY UP-TO-DATE AVAILABLE AGE # nginx 1/1 1 1 97m # postgres 1/1 1 1 97m # server 1/1 1 1 97m kubectl delete deploy nginx postgres server kubernetesからservicesの情報を取得して、現在存在するservicesの情報をKubernetesから削除します。 kubectl get svc # NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE # kubernetes ClusterIP 10.96.0.1 443/TCP 6d21h # nginx NodePort 10.106.171.137 8000:30445/TCP 100m # postgres ClusterIP 10.109.66.138 5432/TCP 100m # server ClusterIP 10.96.82.23 3001/TCP 100m kubectl delete svc nginx postgres server kubernetesから各情報が削除されたことを確認します。 ※service/kubernetesは標準で起動されるものとなります。 kubectl get pod,svc,deploy # NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE # service/kubernetes ClusterIP 10.96.0.1 443/TCP 6d21h "},"Chocolatery.html":{"url":"Chocolatery.html","title":"Chocolateryインストール手順","keywords":"","body":"Chocolateryインストール手順 Chocolateryとは OSや言語毎にパケージマネージャとよばれるツールが提供され、ソフトウエアや拡張機能のインストールはパッケージマネージャを利用して行うことができます。 ChocolateryはWindows用のパッケージマネージャーとなります。 インストール手順 Power Shellを起動する Windowsのスタートボタンを押します。 メニューにある「Windows PowerShell」から「Windows PowerShell」を選択します。 Chocolatery公式サイトにあるインストールページにアクセスし、インストールコマンドを確認します。 Power Shellにインストールコマンドを入力し、実行します。 PS C:\\> Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) 動作確認 chocoコマンドが実行できればインストール完了です。 PS C:\\> choco list -l Chocolatey v0.10.15 chocolatey 0.10.15 1 packages installed. 以上でインストールは完了です。 "},"Homebrew.html":{"url":"Homebrew.html","title":"Homebrewインストール手順","keywords":"","body":"Homebrewインストール手順 Homebrewとは OSや言語毎にパケージマネージャとよばれるツールが提供され、ソフトウエアや拡張機能のインストールはパッケージマネージャを利用して行うことができます。 HomebrewはMac用のパッケージマネージャーとなります。 インストール手順 ターミナルを起動する。 インストールページにアクセスし、インストールコマンドを確認します。 ターミナルにインストールコマンドを入力し、実行します。 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" 動作確認 brewコマンドが実行できればインストール完了です。 brew -v Homebrew 2.2.11 Homebrew/homebrew-core (git revision 23625a; last commit 2020-03-25) 以上でインストールは完了です。 "},"Company.html":{"url":"Company.html","title":"会社紹介","keywords":"","body":"会社紹介 miracleaveでは、「テクノロジーで未来を切り拓く」をミッションに掲げ、 国内だけでなく、今後は海外向けのサービス展開に取り組み、日本を含む世界中の人々に感謝されるようなサービスを提供していきます。 「新しいことに挑戦したい」「自分の技術を磨きたい」など、あなたが持つポジティブなモチベーションを、miracleaveという舞台の「主役」として最大限に発揮しませんか？ 技術スタック この他にもプロジェクトによって、様々なものを活用しています！ mirameetとは 月に1度、社外にも開放した勉強会を様々なテーマで開催しています。一人で勉強して満足するのではなく、“人に伝える”ということも大事にしており、社内外問わず発信しています。 他社さんとタイアップしたり、とにかく楽しく！まずやってみるをモットーにフラットに意見を言い合ってより価値の高いものを作ろうとしています。 ミラコミとは 弊社が独自に運営しているコミュニティです！ コミュニティでは、開発ナレッジ見ることができたり、もくもく会を開催したり、弊社メンバーに限らずベンチャー社員、フリーランスの方が参加しており、技術を高めながら、エンジニア同士の横のつながりも作ることができます。 他にもBBQやダーツ大会、ボードゲーム、スマブラ大会などとにかく楽しくをモットーにスキルアップだけではなく様々なイベントにも参加いただけます。 "}}